//동서남북으로 한칸씩
//흰색은 갈 수 있음. 검은색은 갈 수 없음.
//Maps 칸의 갯수의 최솟값
//도착할 수 없을땐 -1 return
//BFS로 풀어야함?. -> 큐를 사용 
[
  [1, 0, 1, 1, 1],
  [1, 0, 1, 0, 1],
  [1, 0, 1, 1, 1],
  [1, 1, 1, 0, 1],
  [0, 0, 0, 0, 1],
];
내 생각: [0, 0]에서 시작해서[4, 4]까지 가는것
1.[0, 0]에서 시작해서 동서남북으로 한칸씩 갈 수 있는지 확인
0, 0이 1이니 ? 저장 
0, 0에서 시작 
[1, 0], [0, 1], [0, -1], [-1, 0]을 확인 
그다음엔 ? 
[1, 0]에서 시작 
[2, 0], [1, 1], [1, -1], [0, 0]을 확인'
//재귀를 호출하기 
const bfs = (maps, x, y) => { 
    maps[x][y] = 0;

    maps[x - 1][y]
    maps[x][y - 1]
    maps[x + 1][y]
    maps[x-1][y + 1]
}
//풀이 
const n = maps.length;
const m = maps[0].length;
const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; //상하좌우 
//1. 큐를 초기화 
const queue = [[0, 0]];
maps[0][0] = 1 // 시작점 방문 
//큐에서 노드를 꺼내면서 네 방향으로 이동할 수 있는지 확인. 
//이동할 수 있는 경우 큐에 넣고, 방문한 칸의 거리를 갱신 
//목표지점에 도달 시 그지점의 거리를 반환 
while (queue.length > 0) {
    const [x, y] = queue.shift(); //첫번째 요소 반환 
    //현재 위치에서 네 방향으로 위치 확인 
 // 목표 지점에 도달했을 때
 if (x === n - 1 && y === m - 1) {
    return maps[x][y];
}

// 현재 위치에서 네 방향으로 탐색
for (const [dx, dy] of directions) {
    const nx = x + dx;
    const ny = y + dy;

    // 맵을 벗어나지 않고, 벽이 아니며, 방문하지 않은 위치라면
    if (nx >= 0 && nx < n && ny >= 0 && ny < m && maps[nx][ny] === 1) {
        queue.push([nx, ny]);
        // 방문 처리 및 거리 갱신
        maps[nx][ny] = maps[x][y] + 1;
    }
}
}

[
    [1, 0, 9, 10, 11],
    [2, 0, 8, 0, 12],
    [3, 0, 7, 8, 13],
    [4, 5, 6, 0, 14],
    [0, 0, 0, 0, 15]
]